import { Divider, Grid, IconButton, Typography, Box, Slider } from '@mui/material'
import { Stage, Layer, Rect, Circle, Line, Image } from 'react-konva';
import React, { useEffect, useState } from 'react'
import EditorButtonPanel from '../../../Buttons/EditorButtons/EditorButtonPanel'
import CreateIcon from '@mui/icons-material/Create';
import TextFieldsIcon from '@mui/icons-material/TextFields';
import InterestsIcon from '@mui/icons-material/Interests';
import FormatColorFillIcon from '@mui/icons-material/FormatColorFill';
import DisabledByDefaultIcon from '@mui/icons-material/DisabledByDefault';
import EraserIcon from '../../../Icons/EraserIcon';
import { useParams } from 'react-router-dom';
import { SliderPicker, PhotoshopPicker, SketchPicker, CustomPicker } from 'react-color';
import { Colors } from '../../../../Common/Theme';
import SubmitButton from '../../../Buttons/SubmitButton';
import useImage from 'use-image';
import Utils from '../../../../Utils';
import { Buffer } from 'buffer';
import { GlobalStoreContext } from '../../../../Store';


import prefabs from '../../../../prefab.json';
import API from '../../../../API';
import types from '../../../../Common/Types';
import { Text } from 'react-konva';
import { TextField } from '@mui/material';


/* NOTES:

    When we export/import remember to have all the pages and...
    Each page has:
        1. Serialization data
        2. Background Color

    TODO: Add new page button
    TOOD: Resizeable sticker creation canvas

*/

let editorWidth = 800;
let editorHeight = 800;

const viewType = {
    main: "main",
    sticker: "sticker"
}

const STICKER_TAB_TYPE = {
    PREFAB_TAB: "Prefab",
    STICKER_TAB: "Sticker"
}

const toolType = {
    NONE: "",
    pencil: "pencil",
    eraser: "eraser",
    bucket: "bucket",
    text: "text"
};

const pencilType = {
    solid: 0,
    dotted: 50,
    dashed: 100
};

let transactions = [];
let transactionIndex = -1;

const transactionTypes = {
    createLine: "createLine",
    createImage: "createImage",
    moveImage: "moveImage",
    changeBackgroundColor: "changeBackgroundColor",
    addText: "addText",
    moveText: "moveText",
    modifyText: "modifyText"
};

function createTransEntry(name, before, after, id) {
    const entry = {
        transactionName: name,
        before: before,
        after: after,
        id: id
    };

    // console.log("BEFORE:", transactions);

    if ((transactionIndex < 0) || (transactionIndex < (transactions.length - 1))) {
        for (let i = transactions.length - 1; i > transactionIndex; i--) {
            transactions.splice(i, 1);
        }
    }

    // console.log("AFTER:", transactions);

    transactions[++transactionIndex] = entry;
}

function peekTransStack() {
    return transactions[transactionIndex];
}

let undoStack = [];



function clearTransactions() {
    undoStack = [];
    transactions = [];
    transactionIndex = -1;
}

// All supported shapes 
const supportedShapes = {
    line: "line",
    image: "image",
    text: "text"
};

// function from https://stackoverflow.com/a/15832662/512042
function downloadURI(uri, name) {
    var link = document.createElement('a');
    link.download = name;
    link.href = uri;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

function dataURItoBlob(img) {

    // string generated by canvas.toDataURL()
    // strip off the data: url prefix to get just the base64-encoded bytes
    var data = img.replace(/^data:image\/\w+;base64,/, "");
    var buf = new Buffer(data, 'base64');

    return new File([buf], "Tempo", { type: "image/png" });
}

const URLImage = ({ image, onDragMove, onDragEnd, draggable }) => {
    const [img] = useImage(image.src);

    let width = (img) ? img.width : 0;
    let height = (img) ? img.height : 0;

    // overwrite for now
    width = (img) ? 128 : 0;
    height = (img) ? 128 : 0;

    if (image.isSticker) {
        width = editorWidth;
        height = editorHeight;
    }

    return (
        <Image
            width={width}
            height={height}
            image={img}
            x={image.x}
            y={image.y}
            // I will use offset to set origin to the center of the image
            offsetX={img ? width / 2 : 0}
            offsetY={img ? height / 2 : 0}
            draggable={Boolean(draggable)}
            onDragEnd={onDragEnd}
            onDragMove={onDragMove}
        />
    );
};

export default function ComicCreationScreen() {
    const { id } = useParams();

    const { store } = React.useContext(GlobalStoreContext)

    const [view, setView] = useState(viewType.main);

    const [stickerTab, setStickerTab] = useState(STICKER_TAB_TYPE.PREFAB_TAB);

    const [currentColor, setCurrentColor] = useState({
        r: '119',
        g: '89',
        b: '64',
        a: '1',
    });
    const [currentTextColor, setCurrentTextColor] = useState(`rgba(0,0,0,1)`);

    const [textEditModeOn, setTextEditModeOn] = useState(false);
    const [shapeModeOn, setShapeModeOn] = useState(false);

    // Stickers!
    const [stickers, setStickers] = useState([]);

    const [backgroundColor, setBackgroundColor] = useState('white');

    function rgbaToCss() {
        return `rgba(${currentColor.r},${currentColor.g},${currentColor.b},${currentColor.a})`;
    }

    function rgbaToCssText({ r, g, b, a }) {
        console.log("Current text color: ", currentTextColor)
        return `rgba(${r},${g},${b},${a})`;
    }


    const [fontSize, setFontSize] = useState(12)
    const handleFontSizeChange = (e, newValue, modify) => {
        //Set the text
        let oldData = { ...(serialization[currentTextId].data) }
        let newData = { ...oldData }
        newData.fontSize = newValue
        if (modify) {
            serialization[currentTextId].data = newData
        }

        console.log("oldData: ", oldData)
        addOp(transactionTypes.modifyText, serialization.concat(), transactionTypes.modifyText, modify, oldData, serialization[currentTextId].data, currentTextId);
        setFontSize(newValue)
    }

    const [penSize, setPenSize] = useState(5);
    const handlePenSizeChange = (event, newValue) => {
        setPenSize(newValue);
    };

    const [currentPencilType, setCurrentPencilType] = useState(pencilType.solid);
    const handlePencilTypeChange = (event, newValue) => {
        // console.log("hptc:", newValue);
        setCurrentPencilType(newValue);
    };

    const marks = [];
    for (let i = 0; i <= 100; i += 10) {
        marks.push({
            value: i,
            label: "" + i
        });
    }

    const penTypeMarks = [
        {
            value: 0,
            label: "Solid"
        },
        {
            value: 50,
            label: "Dotted"
        },
        {
            value: 100,
            label: "Dashed"
        }
    ];

    function valuetext(value) {
        return `${value}`;
    }

    const handleColorChange = function (color) {
        setCurrentColor(color.rgb);
    }

    const handleTextColorChange = function (color, modify) {
        let oldData = { ...serialization[currentTextId].data }
        let newData = { ...oldData }
        newData.color = rgbaToCssText(color.rgb);
        setCurrentTextColor(newData.color);

        if (modify) {
            serialization[currentTextId].data = newData
        }


        addOp(transactionTypes.modifyText, serialization.concat(), transactionTypes.modifyText, modify, oldData, serialization[currentTextId].data, currentTextId);
    }

    // Konva Related things ------------------------
    const stageRef = React.useRef();
    const dragUrl = React.useRef();
    const [tool, setTool] = React.useState(toolType.NONE);
    const canDrag = Boolean(tool === toolType.NONE);
    const isDrawing = React.useRef(false);

    // ------------------------------------------------------------------------------------------------------------------------  

    // Array of all the pages (TODO: Fetch them)
    // const _pages = [];

    const pageHeight = 100
    // for (let i = 0; i < 30; i++) {
    //     _pages.push(
    //         {
    //             index: i,
    //             data: {
    //                 backgroundColor: 'white',
    //                 serialization: []
    //             }
    //         }
    //     );
    // }

    const [pages, setPages] = useState([{
        index: -12,
        data: {
            backgroundColor: 'white',
            serialization: []
        }
    }]);

    const [pageIndex, setPageIndex] = useState(0);
    const [currentTextId, setCurrentTextId] = useState(-1);

    const defaultPage = (pageIndex >= 0) ? pages[pageIndex].data : [];

    // If in sticker view then we have an empty page
    const [currentPage, setCurrentPage] = useState(defaultPage);

    const [shadow, setShadow] = useState(false);

    useEffect(function () {
        console.log("Pages just changed");
        setCurrentPage(pages[pageIndex].data);

    }, [pages]);

    React.useEffect(function () {
        async function helper(id) {
            try {
                const res = await API.Comic.viewUnpublished(id);

                // console.log("~> page:", res);
                console.log("~>:", res.data.content.pages);
                setPages(res.data.content.pages.concat());
                return;
            }
            catch (err) {

            }

            console.log("Error in loading...");
        }

        helper(id);
    }, []);

    console.log("Pages:", pages);


    useEffect(function () {
        console.log("Index changed...", pageIndex);

        let which;
        // Special case for creating a sticker
        if (pageIndex === -1) {
            console.log("Creating a sticker");
            which = {
                backgroundColor: 'white',
                serialization: []
            };
        }
        else {
            which = pages[pageIndex].data;
        }

        // Clear the transaction stack
        clearTransactions();

        setCurrentPage(which)
    }, [pageIndex]);


    useEffect(function () {
        if (view === viewType.sticker) {
            console.log("Setting the sticker page");
            setPageIndex(-1);
        }
        else {
            console.log("Returning to main...");
            setPageIndex(0);
        }
    }, [view]);

    const onPageClick = function (index) {
        console.log("Trying to change to page with index:", index);

        saveHook();
        setPageIndex(index);
    }

    // The serialization for the comic page we are viewing
    const [serialization, setSerialization] = useState(currentPage.serialization);

    useEffect(function () {
        console.log("Current page changed:", currentPage);
        setSerialization(currentPage.serialization);
        setBackgroundColor(currentPage.backgroundColor);
    }, [currentPage]);





    const onFinishSticker = async function () {
        console.log("Finished Making the sticker:", serialization);

        // Export the serialization

        const uri = stageRef.current.toDataURL();

        // console.log("URI", uri)

        async function helper(img) {
            // console.log("Helper :D ", img);
            let url = null;
            let res = null;

            try {
                url = await Utils.uploadFile(dataURItoBlob(img))

                // Upload the sticker
                res = await API.Comic.saveSticker(url);
            }
            catch (err) {
                console.log("Error with api calls");
                setView(viewType.main);
                return;
            }

            console.log(url, res.status);

            const entry = {
                name: "Sticker!",
                src: url
            };

            setStickers([...stickers, entry]);
            setView(viewType.main);
        }

        helper(uri);
    }

    const onFinishStickerNoSave = function () {
        console.log("ofsns");

        store.createModal({
            title: "Are you sure you don't want to save?",
            body: "You will lose your unsaved sticker",
            action: "Discard Sticker"
        },
            async function () {
                console.log("Discarding...");

                setView(viewType.main);
            }
        );
    }

    function constructEntry(typeName, data) {
        return ({
            typeName: typeName,
            data: data
        });
    }

    function peekSerial() {
        return serialization[serialization.length - 1];
    }

    function peekUndoStack() {
        return undoStack[undoStack.length - 1];
    }

    // Either returns last one or undefined
    function getLastOfType(typeName) {
        return serialization.filter(function (elem) {
            return elem.typeName === typeName;
        }).reverse()[0];
    }


    // ------------------------------------------------------------------------------------------------------------------------

    function exportCurrentPage() {
        const pageObj = {
            backgroundColor: backgroundColor,
            serialization: serialization
        };

        return pageObj;
    }

    function exportPages() {
        // Update the current page
        pages[pageIndex].data = exportCurrentPage();

        // And return them all
        return pages;
    }

    // ------------------------------------------------------------------------------------------------------------------------

    const saveHook = function () {
        console.log("Saving...");

        if (pageIndex === -1) {
            console.log("Saving sticker...");

            const stickerObj = exportCurrentPage();
            console.log("Sticker:", stickerObj);
        }

        const pagesData = exportPages();
        console.log("cpgsd:", pagesData);

        async function pushToServer(pagesData) {
            console.log("pagesData:", pagesData);
            const res = await API.Comic.saveContent(id, pagesData);
            console.log("PUSHED!:", res);
            setPages(pagesData.concat());
        }

        pushToServer(pagesData);
    }

    const handleAddPageClick = function () {
        console.log("Attempting to add a new page")

        const new_page = {
            index: pages.length,
            data: {
                backgroundColor: 'white',
                serialization: []
            }
        };

        async function pushToServer(pagesData) {
            const res = await API.Comic.saveContent(id, pagesData);
            console.log("PUSHED!:", res);
            setPages(pagesData);
        }

        pushToServer([...exportPages(), new_page]);
    }

    if (!serialization)
        return <div>Loading...</div>

    const metadataHook = function () {

        console.log("Trying to access metadata edit page")

        //TODO: Set ID
        store.reRoute(types.TabType.CREATION.children.METADATA.fullRoute, id)
    }

    const undoHook = function () {
        //const recentState = historyState.mostRecent;
        console.log("Trying to undo...");

        handleUndo();
    };

    const redoHook = function () {
        //const recentState = historyState.mostRecent;
        console.log("Trying to redo...");

        handleRedo();
    };

    const addOp = function (typeName, op, transactionName, modify, before, now, id) {
        if (transactionName === transactionTypes.createLine) {
            if (modify) {
                // console.log("Created entry...");
                createTransEntry(transactionTypes.createLine);
            }

            setSerialization(op);
        }
        else if (transactionName === transactionTypes.createImage) {
            if (modify)
                createTransEntry(transactionTypes.createImage);

            setSerialization(op);
        }
        else if (transactionName === transactionTypes.moveImage) {
            if (modify)
                createTransEntry(transactionTypes.moveImage, before, now, id)

            setSerialization(op);
        }
        else if (transactionName === transactionTypes.changeBackgroundColor) {
            if (modify) {
                console.log("ctefbc");
                createTransEntry(transactionTypes.changeBackgroundColor, before, now)
            }

            setBackgroundColor(now);
        } else if (transactionName === transactionTypes.addText) {
            if (modify) {
                console.log("asftttc");
                setTextEditModeOn(true);
                setShapeModeOn(false);
                setCurrentTextId(id);
                setTool(toolType.NONE);
                createTransEntry(transactionTypes.addText);
            }
            setSerialization(op)
        } else if (transactionName === transactionTypes.moveText) {
            if (modify) {
                createTransEntry(transactionTypes.moveText, before, now, id)
            }
            setSerialization(op);
        } else if (transactionName === transactionTypes.modifyText) {
            if (modify) {
                console.log("Modify text")
                createTransEntry(transactionTypes.modifyText, before, now, id)
            }
            setSerialization(op);
        }
        else {
            console.log("Unsupported transaction");
        }
    };

    const handleUndo = function () {
        const transaction = peekTransStack();

        // console.log("t", transaction, transactions);

        if (!transaction)
            return;

        if (transactions.length === 0 || transactionIndex < 0)
            return

        if (transaction.transactionName === transactionTypes.createLine) {
            const last = peekSerial();

            if (!last)
                return;

            //console.log("Setting (from undo) to:", undoStack, serialization);
            if (serialization.length === 0) {
                return;
            }

            undoStack = [...undoStack, last];

            //console.log("Setting (from undo) to:", undoStack, serialization);

            transactionIndex--;

            setSerialization(serialization.slice(0, -1));
        }
        else if (transaction.transactionName === transactionTypes.createImage) {
            const last = peekSerial();

            if (!last)
                return

            undoStack = [...undoStack, last];
            transactionIndex--;

            setSerialization(serialization.slice(0, -1));
        }
        else if (transaction.transactionName === transactionTypes.moveImage) {
            const id = transaction.id;

            const before = transaction.before;
            const after = transaction.after;

            console.log("before, after:", before, after);

            const x = before.x;
            const y = before.y;

            // const oldX = after.x;
            // const oldY = after.y;

            const elem = serialization[id];

            if (elem) {
                elem.data.x = x;
                elem.data.y = y;

                serialization.splice(id, 1, elem);

                transactionIndex--;

                setSerialization(serialization.concat());
            }
        }
        else if (transaction.transactionName === transactionTypes.changeBackgroundColor) {
            const before = transaction.before;
            // const after = transaction.after;

            transactionIndex--;

            setBackgroundColor(before);
        }
        else if (transaction.transactionName === transactionTypes.modifyText) {
            // console.log("Undo modify text with transaction id", transaction.id)
            const id = transaction.id;

            const before = transaction.before;
            const after = transaction.after;

            console.log("Before: ", before)

            const elem = serialization[id];

            if (elem) {
                elem.data = { ...before };

                serialization.splice(id, 1, elem);
                setFontSize(before.fontSize)
                setCurrentTextColor(before.color)

                transactionIndex--;

                setSerialization(serialization.concat());
            }
        } else if (transaction.transactionName === transactionTypes.addText) {
            const last = peekSerial();

            if (!last)
                return;

            //console.log("Setting (from undo) to:", undoStack, serialization);
            if (serialization.length === 0) {
                return;
            }

            undoStack = [...undoStack, last];

            //console.log("Setting (from undo) to:", undoStack, serialization);

            transactionIndex--;

            setSerialization(serialization.slice(0, -1));
            setTextEditModeOn(false);
        } else if (transaction.transactionName === transactionTypes.moveText) {
            const id = transaction.id;

            const before = transaction.before;
            const elem = { ...serialization[id] };

            if (elem) {
                elem.data.x = before.x
                elem.data.y = before.y

                serialization.splice(id, 1, elem);

                transactionIndex--;

                setSerialization(serialization.concat());
            }
        }
        else {
            console.log("Unsupported transaction");
        }
    };

    const handleRedo = function () {
        // console.log("bt", peekTransStack(), transactions, transactionIndex);

        transactionIndex++;
        const transaction = peekTransStack();
        // console.log("t", transaction, transactions);
        if (transaction === null || transaction === undefined) {
            console.log("err 1");
            transactionIndex--;
            return;
        }

        if (transactions.length === 0) {
            console.log("err 2");
            transactionIndex--;
            return;
        }

        if (transaction.transactionName === transactionTypes.createLine) {
            const last = peekUndoStack();

            if (!last) {
                transactionIndex--;
                return;
            }

            if (undoStack.length === 0) {
                transactionIndex--;
                return;
            }

            const newSerialization = [...serialization, undoStack.pop()];

            //console.log("Setting (from redo) to:", undoStack, newSerialization);

            setSerialization(newSerialization);

        }
        else if (transaction.transactionName === transactionTypes.createImage) {
            const last = peekUndoStack();

            if (!last) {
                transactionIndex--;
                return;
            }

            if (undoStack.length === 0) {
                transactionIndex--;
                return;
            }

            const newSerialization = [...serialization, undoStack.pop()];

            //console.log("Setting (from redo) to:", undoStack, newSerialization);

            setSerialization(newSerialization);
        }
        else if (transaction.transactionName === transactionTypes.moveImage) {
            const id = transaction.id;

            const before = transaction.before;
            const after = transaction.after;

            console.log("before, after:", before, after);

            // const x = before.x;
            // const y = before.y;

            const oldX = after.x;
            const oldY = after.y;

            const elem = serialization[id];

            if (elem) {
                elem.data.x = oldX;
                elem.data.y = oldY;

                serialization.splice(id, 1, elem);

                setSerialization(serialization.concat());
            }
            else {
                transactionIndex--;
            }
        }
        else if (transaction.transactionName === transactionTypes.changeBackgroundColor) {
            // const before = transaction.before;
            const after = transaction.after;

            // console.log("->", after);

            setBackgroundColor(after + " ");
        } else if (transaction.transactionName === transactionTypes.modifyText) {
            const id = transaction.id;

            const elem = serialization[id];
            let after = transaction.after;

            if (elem) {
                elem.data = after;
                serialization.splice(id, 1, elem);
                setFontSize(after.fontSize)
                setCurrentTextColor(after.color)

                setSerialization(serialization.concat());
            }
            else {
                transactionIndex--;
            }
        } else if (transaction.transactionName === transactionTypes.addText) {
            const last = peekUndoStack();

            if (!last) {
                transactionIndex--;
                return;
            }

            if (undoStack.length === 0) {
                transactionIndex--;
                return;
            }

            const newSerialization = [...serialization, undoStack.pop()];

            //console.log("Setting (from redo) to:", undoStack, newSerialization);

            setSerialization(newSerialization);

        } else if (transaction.transactionName === transactionTypes.moveText) {
            const id = transaction.id;
            const after = transaction.after;
            const elem = serialization[id];

            if (elem) {
                elem.data.x = after.x;
                elem.data.y = after.y;

                serialization.splice(id, 1, elem);

                setSerialization(serialization.concat());
            }
            else {
                transactionIndex--;
            }
        }
        else {
            console.log("Unsupported transaction");
            transactionIndex--;
        }
    };

    // ------------------------------------------------------------------------------------------------------------------------

    const stickersSectionBackgroundColor = "rgba(170,170,170, 1)"

    //TODO
    let prefabsTabBackgroundColor = stickersSectionBackgroundColor
    let stickersTabBackgroundColor = "transparent"

    switch (stickerTab) {
        case STICKER_TAB_TYPE.PREFAB_TAB:
            prefabsTabBackgroundColor = stickersSectionBackgroundColor;
            stickersTabBackgroundColor = "transparent"
            break;
        case STICKER_TAB_TYPE.STICKER_TAB:
            prefabsTabBackgroundColor = "transparent";
            stickersTabBackgroundColor = stickersSectionBackgroundColor;
            break;
        default:
            break;
    }

    const handleTextChange = function (e) {
        e.preventDefault();

        //Set the text
        let oldData = { ...(serialization[currentTextId].data) }
        let newData = { ...oldData }
        newData.text = e.target.value
        serialization[currentTextId].data = newData
        console.log("oldData: ", oldData)
        addOp(transactionTypes.modifyText, serialization.concat(), transactionTypes.modifyText, true, oldData, serialization[currentTextId].data, currentTextId);
    }

    const handleTextClick = function (id) {
        setTextEditModeOn(true);
        setFontSize(serialization[id].data.fontSize)
        setCurrentTextColor(serialization[id].data.color)
        setShapeModeOn(false);
        setCurrentTextId(id);
    }

    // TODO: Do we have to do anything here???
    const handleDragMove = function (e, id) { }

    const handleDragEnd = function (e, id) {
        const elem = serialization[id];

        if (elem) {
            const x = e.target.attrs.x;
            const y = e.target.attrs.y;

            if (elem.typeName === supportedShapes.image) {
                console.log("x y", elem.data, x, y);

                const oldX = elem.data.x;
                const oldY = elem.data.y;

                elem.data.x = x;
                elem.data.y = y;

                serialization.splice(id, 1, elem);

                addOp(supportedShapes.image, serialization.concat(), transactionTypes.moveImage, true, { x: oldX, y: oldY }, { x: x, y: y }, id);
            } else if (elem.typeName === supportedShapes.text) {
                console.log("x y", elem.data, x, y);

                const oldX = elem.data.x;
                const oldY = elem.data.y;

                elem.data.x = x;
                elem.data.y = y;

                serialization.splice(id, 1, elem);

                addOp(supportedShapes.text, serialization.concat(), transactionTypes.moveText, true, { x: oldX, y: oldY }, { x: x, y: y }, id);
            }
            else if (elem.typeName === supportedShapes.line) {
                console.log("x y", elem.data.points, x, y, e);
            }
        }
    }

    const handlePencilClick = function () {
        setTextEditModeOn(false)
        if (tool === toolType.pencil)
            setTool(toolType.NONE);
        else {
            setTool(toolType.pencil);
        }
    }

    const handleEraserClick = function () {
        setTextEditModeOn(false)
        if (tool === toolType.eraser)
            setTool(toolType.NONE);
        else {
            console.log("Setting eraser");
            setTool(toolType.eraser);
        }
    }

    // Changes background color
    const handleFillClick = function () {
        setTextEditModeOn(false)
        console.log("changeing backgorund...");

        addOp(null, null, transactionTypes.changeBackgroundColor, true, backgroundColor, rgbaToCss());
    }

    const handleShapesClick = function () {
        setTextEditModeOn(false)
        setShapeModeOn(!shapeModeOn);
    }

    const handleTextButtonClick = function () {
        if (tool === toolType.text) {
            setTool(toolType.NONE)
        } else {
            setTool(toolType.text)
        }
    }

    // TODO:
    const handlePrefabsTabClick = function () {
        setStickerTab(STICKER_TAB_TYPE.PREFAB_TAB)
    }

    const handleStickersTabClick = function () {
        setStickerTab(STICKER_TAB_TYPE.STICKER_TAB)
    }

    const prefabContent = prefabs.map(function (img, i) {
        return (
            <Grid item key={i}>
                <img
                    alt={img.name}
                    src={img.src}
                    draggable={true}
                    width={128}
                    height={128}
                    onDragStart={(e) => {
                        dragUrl.current = e.target.src;
                    }}
                />
            </Grid>
        );
    });

    const stickersContent = stickers.map(function (img, i) {
        return (
            <Grid item key={i}>
                <div style={{
                    backgroundColor: "white",
                    border: "1px solid black",
                    paddingBottom: "4px"
                }} >
                    <img
                        alt={img.name}
                        src={img.src}
                        draggable={true}
                        width={128}
                        height={128}
                        onDragStart={(e) => {
                            dragUrl.current = e.target.src;
                        }}
                    />
                </div>
            </Grid>
        );
    });

    function pageComponent({ key }) {
        return (
            <Grid item>
                <Box itemId={key} key={key} onClick={(event) => onPageClick(key)}>
                    <div style={{
                        backgroundColor: (key === pageIndex) ? Colors.cadet_blue : "white",
                        height: pageHeight,
                        width: pageHeight,
                        margin: 10,
                        border: "1px solid black",
                        display: "flex",
                        justifyContent: "center",
                        position: 'relative',
                        cursor: 'pointer'
                    }}
                    >
                        <div style={{
                            height: "100%",
                            display: "table"
                        }}>
                            <Typography variant="h3" sx={{
                                display: "table-cell",
                                verticalAlign: "middle"
                            }}>
                                {key}
                            </Typography>
                        </div>
                    </div>
                </Box >
            </Grid>
        );
    }

    const buildPages = function () {
        //console.log("~>", pages);
        return pages.map((pageJSON, i) => {
            return (
                pageComponent({
                    key: i
                })
            );
        });
    }


    const borderSpecs = "2px solid " + Colors.coffee

    let toolbar =
        <Grid container direction="column">
            <Grid item>
                <Typography variant="h5">
                    Tools
                </Typography>
            </Grid>
            <Grid item>
                <Grid container direction="row" justifyContent="space-between">
                    <IconButton onClick={handlePencilClick} sx={{ border: (tool === toolType.pencil) ? borderSpecs : "" }}>
                        <CreateIcon sx={{ width: 35, height: 35, color: rgbaToCss() }} />
                    </IconButton>
                    <IconButton onClick={handleEraserClick} sx={{ border: (tool === toolType.eraser) ? borderSpecs : "" }}>
                        <EraserIcon sx={{ width: 30, height: 30 }} />
                    </IconButton>
                    <IconButton disabled={Boolean(view === viewType.sticker || textEditModeOn)} onClick={handleFillClick} sx={{ border: (tool === toolType.bucket) ? borderSpecs : "" }}>
                        {(view === viewType.sticker || textEditModeOn) ? <DisabledByDefaultIcon sx={{ width: 35, height: 35, color: 'gray' }} /> : <FormatColorFillIcon sx={{ width: 35, height: 35, color: rgbaToCss() }} />}
                    </IconButton>
                    {/* // TODO: */}
                    <IconButton onClick={handleShapesClick} sx={{ border: (shapeModeOn) ? borderSpecs : "" }}>
                        <InterestsIcon sx={{ width: 35, height: 35, color: rgbaToCss() }} />
                    </IconButton>
                    <IconButton onClick={handleTextButtonClick} sx={{ border: (tool === toolType.text) ? borderSpecs : "" }}>
                        <TextFieldsIcon sx={{ width: 35, height: 35, color: "black" }} />
                    </IconButton>
                </Grid>
            </Grid>
        </Grid>

    const stickersTabs =
        <Grid container direction="row" width="max-content" spacing={1}>
            <Grid item width="max-content" onClick={handlePrefabsTabClick} sx={{ cursor: "pointer" }}>
                <div style={{ padding: "15px 15px 25px 15px", borderRadius: 5, backgroundColor: prefabsTabBackgroundColor }}>
                    <Typography variant="h6" width="max-content">
                        Prefabs
                    </Typography>
                </div>
            </Grid>
            <Grid item width="max-content" onClick={handleStickersTabClick} sx={{ cursor: "pointer" }}>
                <div style={{ padding: "15px 15px 25px 15px", borderRadius: 5, backgroundColor: stickersTabBackgroundColor }}>
                    <Typography variant="h6" width="max-content">
                        Stickers
                    </Typography>
                </div>
            </Grid>
        </Grid>

    const stickersSection =
        <Grid container direction="column" width="100%" height="100%">
            <Grid item>
                {stickersTabs}
            </Grid>
            <Grid item sx={{ height: "calc(100% - 100px)", marginTop: -3, backgroundColor: stickersSectionBackgroundColor, padding: "10px 0px 10px 0px" }}>
                <div style={{ overflow: "auto", height: "100%", padding: "0px 5px 0px 5px" }}>
                    <Grid container direction="row" justifyContent="center" sx={{ width: "100%" }}>
                        {(stickerTab === STICKER_TAB_TYPE.PREFAB_TAB) ? prefabContent : stickersContent}
                    </Grid>
                </div>
            </Grid>
            <Grid item >
                <div style={{
                    width: "100%",
                    display: "flex",
                    justifyContent: "center",
                    marginTop: "5px"
                }}>
                    {view === viewType.sticker ?
                        <div style={{ width: "100%" }}>
                            <Grid container>
                                <Grid item xs={6}>
                                    <div style={{
                                        width: "100%",
                                        display: "flex",
                                        justifyContent: "center"
                                    }}>
                                        <SubmitButton text={"Save"} onClick={onFinishSticker} />
                                    </div>
                                </Grid>
                                <Grid item xs={6}>
                                    <div style={{
                                        width: "100%",
                                        display: "flex",
                                        justifyContent: "center"
                                    }}>
                                        <SubmitButton text={"Cancel"} onClick={onFinishStickerNoSave} />
                                    </div>
                                </Grid>
                            </Grid>
                        </div>
                        : <SubmitButton text={"Create Sticker"} onClick={
                            function () {
                                saveHook();
                                setView(viewType.sticker);
                            }
                        } />}
                </div>
            </Grid>
        </Grid>

    let optionsPanel = (textEditModeOn) ?
        <Grid container direction="row" justifyContent="center" alignItems="center" width="100%" spacing={3}>
            <Grid item xs={12}>
                <Box sx={{
                    justifyContent: "center",
                    display: "flex"
                }}>
                    <TextField
                        sx={{ width: "100%" }}
                        onChange={handleTextChange}
                        color="text"
                        placeholder="Edit Text Here"
                        variant="filled"
                        value={serialization[currentTextId].data.text}
                        multiline
                        maxRows={4}
                    />
                </Box>
            </Grid>
            <Grid item xs={12}>
                <Box sx={{
                    justifyContent: "center",
                    display: "flex"
                }}>
                    <SketchPicker
                        color={currentTextColor}
                        onChange={(e) => { handleTextColorChange(e, false) }}
                        onChangeComplete={(e) => { handleTextColorChange(e, true) }}
                        presetColors={Object.values(Colors)}
                    />
                </Box>
            </Grid>
            <Grid item xs={12}>
                <Grid container>
                    <Grid item xs={12}>
                        <div style={{
                            width: "100%",
                            display: "flex",
                            justifyContent: "center"
                        }}>
                            <Typography>
                                Font Size
                            </Typography>
                        </div>
                    </Grid>
                    <Grid item xs={12}>
                        <div style={{
                            width: "100%",
                            display: "flex",
                            justifyContent: "center"
                        }}>
                            <Slider
                                aria-label="Font size"
                                value={fontSize}
                                step={1}
                                valueLabelDisplay="auto"
                                marks={marks}
                                onChangeCommitted={(event, newValue) => { handleFontSizeChange(event, newValue, true) }}
                                onChange={(event, newValue) => { handleFontSizeChange(event, newValue, false) }}
                                sx={{
                                    width: "100%",
                                    color: currentTextColor,
                                }}
                            />
                        </div>
                    </Grid>
                </Grid>
            </Grid>
        </Grid>
        :
        <Grid container direction="row" justifyContent="center" alignItems="center" width="100%" spacing={3}>
            <Grid item xs={12}>
                <Box sx={{
                    justifyContent: "center",
                    display: "flex"
                }}>
                    <SketchPicker
                        color={rgbaToCss()}
                        onChange={handleColorChange}
                        presetColors={Object.values(Colors)}
                    />
                </Box>
            </Grid>
            <Grid item xs={12}>
                <Grid container>
                    <Grid item xs={12}>
                        <div style={{
                            width: "100%",
                            display: "flex",
                            justifyContent: "center"
                        }}>
                            <Typography>
                                Pencil/Eraser Size
                            </Typography>
                        </div>
                    </Grid>
                    <Grid item xs={12}>
                        <div style={{
                            width: "100%",
                            display: "flex",
                            justifyContent: "center"
                        }}>
                            <Slider
                                aria-label="Pen size"
                                value={penSize}
                                getAriaValueText={valuetext}
                                step={1}
                                valueLabelDisplay="auto"
                                marks={marks}
                                onChange={handlePenSizeChange}
                                sx={{
                                    width: "100%",
                                    color: (tool === toolType.eraser) ? "black" : rgbaToCss(),
                                }}
                            />
                        </div>
                    </Grid>
                </Grid>
            </Grid>
            <Grid item xs={12}>
                <Grid container>
                    <Grid item xs={12}>
                        <div style={{
                            width: "100%",
                            display: "flex",
                            justifyContent: "center"
                        }}>
                            <Typography>
                                Pencil/Eraser Style
                            </Typography>
                        </div>
                    </Grid>
                    <Grid item xs={12}>
                        <div style={{
                            width: "100%",
                            display: "flex",
                            justifyContent: "center"
                        }}>

                            <Slider
                                aria-label="Restricted values"
                                value={currentPencilType}
                                step={null}
                                marks={penTypeMarks}
                                track={false}
                                onChange={handlePencilTypeChange}
                                sx={{
                                    width: "50%",
                                    color: (tool === toolType.eraser) ? "black" : rgbaToCss()
                                }}
                            />
                        </div>
                    </Grid>
                </Grid>
            </Grid>
        </Grid>


    // ------------------------------------------------------------------------------------------------------------------------


    const handleMouseMove = (e) => {
        // no drawing - skipping
        if (!isDrawing.current) {
            return;
        }
        const stage = e.target.getStage();
        const point = stage.getPointerPosition();
        let lastLineEntry = getLastOfType(supportedShapes.line);
        // console.log("lle:", lastLineEntry);
        let lastLine = lastLineEntry.data;
        // add point
        lastLine.points = lastLine.points.concat([point.x, point.y]);

        // replace last
        serialization.splice(serialization.length - 1, 1, lastLineEntry);
        addOp(supportedShapes.line, serialization.concat(), transactionTypes.createLine, false);
    };

    const handleMouseDown = (e) => {
        if (tool === toolType.pencil || tool === toolType.eraser) {
            isDrawing.current = true;

            const pos = e.target.getStage().getPointerPosition();
            // console.log("P", pos);
            const entry = constructEntry(supportedShapes.line,
                {
                    tool,
                    points: [pos.x, pos.y],
                    color: rgbaToCss(),
                    penSize: penSize,
                    closed: shapeModeOn,
                    pencilType: currentPencilType
                });
            // console.log("Adding entry:", entry);

            addOp(supportedShapes.line, [...serialization, entry], transactionTypes.createLine, true);
        } else if (tool === toolType.text) {
            const pos = e.target.getStage().getPointerPosition();
            const entry = constructEntry(supportedShapes.text,
                {
                    x: pos.x,
                    y: pos.y,
                    text: "Insert text here",
                    fontSize: fontSize,
                    color: currentTextColor
                });
            addOp(supportedShapes.text, [...serialization, entry], transactionTypes.addText, true, null, null, serialization.length);
        }
    };

    const handleMouseUp = () => {
        if (isDrawing.current === true) {
            // console.log("Mouse up...");
        }

        isDrawing.current = false;
    };

    // console.log("sss:", serialization);

    //TODO
    let stageBorderColor = (view === viewType.sticker) ? "blue" : "black"
    const editorWindow =
        <div
            onDrop={(e) => {
                e.preventDefault();
                // register event position
                stageRef.current.setPointersPositions(e);
                // add image

                const entry = constructEntry(supportedShapes.image, {
                    ...stageRef.current.getPointerPosition(),
                    src: dragUrl.current,
                    isSticker: (stickerTab === STICKER_TAB_TYPE.PREFAB_TAB) ? false : true
                });

                addOp(supportedShapes.image, [...serialization, entry], transactionTypes.createImage, true);
            }}
            onDragOver={(e) => e.preventDefault()}
            id="stage-div"
            style={{ width: editorWidth + "px", height: editorHeight + "px", justifyContent: "center", display: "flex", resize: 'both' }}
        >
            <Stage
                width={editorWidth}
                height={editorHeight}
                ref={stageRef}
                style={{ border: "1px solid " + stageBorderColor, background: backgroundColor }}
                onMouseDown={handleMouseDown}
                onMousemove={handleMouseMove}
                onMouseup={handleMouseUp}
            >
                <Layer>
                    {
                        serialization.filter(function (val) {
                            return (val.typeName !== supportedShapes.drag)
                        }).map((shape, i) => {
                            if (shape.typeName === supportedShapes.line) {
                                const line = shape.data;

                                let dashedArr = [];
                                if (line.pencilType === pencilType.dashed) {
                                    dashedArr = [33, 2 * (line.penSize)];
                                }
                                else if (line.pencilType === pencilType.dotted) {
                                    dashedArr = [33, 2 * (line.penSize), 0.001 * (line.penSize), 2 * (line.penSize)];
                                }

                                return (
                                    <Line
                                        key={i}
                                        points={line.points}
                                        perfectDrawEnabled={false}
                                        fill={line.closed ? line.color : ""}
                                        stroke={line.color}
                                        strokeWidth={line.penSize}
                                        closed={line.closed}
                                        tension={0.5}
                                        lineCap={'round'}
                                        lineJoin={'round'}
                                        dash={dashedArr}
                                        globalCompositeOperation={
                                            line.tool === 'eraser' ? 'destination-out' : 'source-over'
                                        }
                                    // draggable={canDrag}
                                    // onDragEnd={(e) => handleDragEnd(e, i)}
                                    // onDragMove={(e) => handleDragMove(e, i)}
                                    />
                                );
                            }
                            else if (shape.typeName === supportedShapes.image) {
                                return (
                                    <URLImage
                                        key={i}
                                        image={shape.data}
                                        draggable={canDrag}
                                        onDragEnd={(e) => handleDragEnd(e, i)}
                                        onDragMove={(e) => handleDragMove(e, i)}
                                    />
                                );
                            } else if (shape.typeName === supportedShapes.text) {
                                const text = shape.data;

                                return (
                                    <Text
                                        key={i}
                                        x={text.x}
                                        y={text.y}
                                        draggable={canDrag}
                                        text={text.text}
                                        fill={text.color}
                                        fontSize={text.fontSize}
                                        onDragEnd={(e) => handleDragEnd(e, i)}
                                        onDragMove={(e) => handleDragMove(e, i)}
                                        onClick={(e) => handleTextClick(i)}
                                    // points={line.points}
                                    // perfectDrawEnabled={false}
                                    // fill={line.closed ? line.color : ""}
                                    // stroke={line.color}
                                    // strokeWidth={line.penSize}
                                    // closed={line.closed}
                                    // tension={0.5}
                                    // lineCap={'round'}
                                    // lineJoin={'round'}
                                    // dash={dashedArr}
                                    // globalCompositeOperation={
                                    //     line.tool === 'eraser' ? 'destination-out' : 'source-over'
                                    // }
                                    // draggable={canDrag}
                                    // onDragEnd={(e) => handleDragEnd(e, i)}
                                    // onDragMove={(e) => handleDragMove(e, i)}
                                    />
                                );
                            }
                            else {
                                // Should not be possible since we filter
                                console.log("IMPOSSIBLE !!");
                                return <div />;
                            }
                        })
                    }
                </Layer>
            </Stage>
        </div>

    // ------------------------------------------------------------------------------------------------------------------------

    const pagesSection = (
        <Grid container direction="column" width="100%" height="100%" justifyContent="space-between" alignItems="center" spacing={2}>
            <Grid item>
                <Typography variant="h5">
                    Pages
                </Typography>
            </Grid>
            <Grid item sx={{ height: "calc(100% - 100px)", marginTop: -3, padding: "10px 0px 10px 0px" }}>
                <div style={{ overflow: "auto", height: "100%", padding: "0px 5px 0px 5px" }}>
                    <Grid container direction="row" justifyContent="center" sx={{ width: "100%" }}>
                        {buildPages()}
                    </Grid>
                </div>
            </Grid>
            <Grid item >
                {view === viewType.sticker ? <div /> : <SubmitButton text={"Add Page"} onClick={
                    handleAddPageClick
                } />}
            </Grid>
        </Grid>
    );

    return (
        <Box sx={{
            height: "100%",
            width: "100%",
            display: "flex"
        }}>
            <Box sx={{
                height: "100%",
                width: "325px",
                float: "left"
            }}>
                <Grid container direction="column" spacing={2} sx={{ height: "100%" }}>
                    <Grid item>
                        <EditorButtonPanel undoHook={undoHook} redoHook={redoHook} saveHook={saveHook} metadataHook={metadataHook} />
                    </Grid>
                    <Grid item>
                        <hr style={{ width: "100%" }} />
                    </Grid>
                    <Grid item>
                        {toolbar}
                    </Grid>
                    <Grid item width="100%">
                        {optionsPanel}
                    </Grid>
                </Grid>
            </Box>
            <Divider orientation="vertical" variant="middle" sx={{ marginRight: 2, marginLeft: 3 }} />
            <Box sx={{
                height: "100%",
                width: "calc(100% - 675px)",
            }}>
                <Box sx={{
                    height: "calc(100% - 200px)",
                    width: "100%",
                    justifyContent: 'center',
                    display: "flex"
                }}>
                    {editorWindow}
                </Box>
            </Box>

            <Box sx={{
                height: "100%",
                width: "250px",
                float: "right"
            }}>
                {stickersSection}
            </Box>
            <Divider orientation="vertical" variant="middle" sx={{ marginRight: 2, marginLeft: 3 }} />
            <Box sx={{
                height: "100%",
                width: "250px",
                float: "right"
            }}>
                {pagesSection}
            </Box>
        </Box >
    );
}
